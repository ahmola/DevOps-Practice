# DevOps-Practice
MSA 설계와 DevOps 연습

## DevOps의 기원과 철학

2000년대 초까지만 하더라도 개발(Dev)은 빠르게 기능 출시, 운영(Ops)은 시스템 안정성 유지라는 서로 다른 목표를 가지고 움직였습니다.

그러다보니, 개발팀과 운영팀간의 마찰이 크게 일어났습니다. 사일로 현상과 잦은 배포 실패가 DevOps의 출발점이 되었습니다.

DevOps는 3가지의 핵심 원칙을 바탕으로 시작합니다.

  1. Flow: 개발 -> 배포 -> 운영의 프로세스를 자동화하여 빠른 피드백 루프 확보
  2. Feedback: 모니터링/로깅/알림 등을 도입하여 운영 피드백을 개발 단계에서 가능하게 함
  3. Continuous Learning: 실패 허용, 지속 개선과 자동화

이러한 DevOps의 철학을 현실로 구현한 기술 스택을 CI/CD 파이프라인(Continuous Integration/Continuous Deployment, 일명 지속 통합/지속 재포)이라고 합니다.

  - CI: 코드 변경 시 자동 테스트/빌드(Jenkins, Github Actions, GitLab CI)
  - CD: 검증된 코드 자동 배포(ArgoCD, Spinnaker, GitOps)
  - Configuration Management: 서버 설정 일관화(Ansible, Chef, Puppet)
  - Containerization: 환경 격리와 이식성 향상(Docker, Podman)
  - Orchestration: 컨테이너 자동 배치(Kubernetes, ECS, Nomad)
  - Monitoring/Loggin: 시스템 관찰 및 피드백(Prometheus, Grafana, ELK(Elasticsearch, Logstash, Kibana), Loki)
  - Infrastructure as Cod(IaC): 인프라 자동 프로비저닝(Terraform, Pulumi, CloudFormation)

DevOps는 GitOps, DevSecOps, AIOps 등으로 확장되었습니다.

Google의 SRE(Site Reliability Engineering)가 DevOps의 확장 개념이기도 합니다.

운영은 개발의 일부고, 코드를 통해 신뢰성을 확보한다가 주된 철학입니다.

현재 트랜드로는, Platform Engineering, GitOps & IaC, Observability & AIOps, FinOps, NoOps(현실적으로는 불가능하나, Serverless와 GitOps로 구체화 중)

## 대규모 분산 시스템에서의 DevOps

하나의 시스템이 있다고 가정해봅시다. 더 직관적으로, 소프트웨어를 출시했다고 생각해봅시다.

과연 어떻게 전 세계의 사람들에게 안정적으로 서비스를 제공하면서도, 개발과 배포를 동시에 진행할 수 있을까요?

일단 너무 크게 보지말고 한 나라에서 운영한다고 생각해봅시다.

안정적으로 한 나라에서 많은 사람들에게 배포를 한다고 생각한다면, 아마 모놀리식(일체형)으로는 불가능할겁니다.

이유는 간단합니다.

인기가 많다는 건 곧 기능이 많거나, 트래픽이 많다는 뜻입니다.

하나의 소프트웨어에 많은 기능이 있고 서로 다른 사용자가 같은 소프트웨어 내에서 서로 다른 서비스를 이용할 확률이 크니, 서로 영향을 주고 받게 되는 구조인거죠.

당연히 자연스럽게 유지보수하기도 힘들고 기능 추가에도 상당한 제약이 발생할겁니다.

그러면 어떻게 이걸 해결할 수 있을까요?

간단합니다. 작게(마이크로) 나누면 되는거죠.

소프트웨어 내 각 서비스(로그인, 마이페이지, 광고 등등)를 독립적으로 운영하면 효율적일 것입니다.

그런데 이렇게 나누면 문제가 발생합니다.

예전에는 한 컴퓨터에서 잘 돌아가면 그만이었지만, 서비스를 나눠서 운영하다보니 서로 다른 컴퓨터에서 운영해야하는 상황이 발생한거죠.

그러다보니 개발은 되지만 운영은 느려지고 개발과 운영이 서로 탓만 하게 되는 문제가 발생합니다.

거기서 등장한게 DevOps였고, 기술적으로 이걸 운영체제에 대한 제약을 받지 않고 배포하여 서비스를 실행할 수 있도록 탄생한 것이 Container였습니다.

"내 컴퓨터에서는 안되는데요?"라는 논쟁이 사라진거죠. 

여기서 소프트웨어가 더 성장하고 사용자 수가 더 증가했다고 가정해보죠.

그러면 더욱 더 많은 서비스를 더 많은 컴퓨터가 운영하게 되면서 규모가 커지게 될 겁니다.

당연히 자연스레 자동화의 압박을 받게 되죠.

여기서 자동화를 위해 컨테이너를 관리하는(오케스트레이션) 작업을 하기 위해 탄생한 것이 쿠버네티스입니다.

쿠버네티스는 마스터 노드와 워커 노드로 구성되어 운영됩니다.

각 노드들은 하나의 서버에서 각각 운영되고, 마스터 노드(컨트롤 플레인)가 워커 노드들을 관리/모니터링/복구 등의 작업을 하게 됩니다.

워커 노드들에는 각 서비스의 파드(하나의 작업 단위, 컨테이너 1개라고 봐도 무방함. 완전히 같은 건 아님)들이 여러 개 관리가 되게 됩니다.

그리고 이런 모든 노드들을 합쳐서 **추상적으로** 부르는 게 된 것이 클러스터입니다.

즉, 시스템(운영하는 프로젝트, 비즈니스) = 클러스터인 것이죠.

이 프로젝트가 너무 잘되서 글로벌 진출에 성공하고 회사가 다른 프로젝트들도 출시해서 운영한다고 가정해봅시다.

그렇게 되면, 여러 클러스터를 감당해야 하는 상황이 오게 됩니다.

배포하는 것도 쉽지 않을테고, 직접 배포하는 것은 더욱 물리적인 비용이 크게 들 것입니다.

여기서 등장한 것이 ansible과 terraform입니다.

Ansible은 서버 운영 환경 설정 자동화를 해주고, Terraform은 클라우드 서비스를 통해 초기 서버를 할당받고 서버 인프라를 관리합니다.

쉽게 말해, terraform으로 aws 인스턴스를 자동 할당받아 초기 세팅을 해주고, ansible을 통해 서비스가 운영될 서버 환경 세팅을 자동으로 해주는 도구들이라고 이해하시면 됩니다.

이게 Infrastructure as Code(IaC)라고 불리는 기술입니다.

즉,

  Terraform(서버 할당, 생성) -> Ansible(서버 세팅) -> Kubernetes(배포)

의 형태로 인프라 세팅 자동화가 이루어지게 됩니다.

그러면 아까 전에, 회사가 여러 개의 시스템(클러스터)을 운영한다고 했는데, 수 많은 시스템을 어떻게 한꺼번에 관리할 수 있을까요?

만약 회사가 운영하는 클러스터가 100개라면? 이것 또한 자동화와 중앙 집중화를 요구하게 됩니다.

여기서 이를 위해서 필요한 플랫폼이 바로 Rancher입니다.

Rancher를 사용하여 수 많은 클러스트들을 중앙 집중적으로 관리할 수 있게 됩니다.

그렇다면 이렇게 수 많은 서비스들의 코드들을 어떻게 관리할까요?

그래서 필요한 것이 CI/CD Pipeline, 그러니까 Jenkins가 필요한 것입니다.

Jenkins를 사용하여 코드를 빌드, 테스트하고 Kubernetes(또는 Helm)을 통해 배포를 자동화 하는 것입니다.

Jenkins 또한 쿠버네티스를 통해서 각 파이프라인들을 관리하게 됩니다.

## DevOps는 기술이 아니다

Dev(개발)과 Ops(운영)을 붙인 이유는 앞서 언급하였듯이, 개발과 운영을 통합하기 위함입니다.

즉, 책임 소재를 명확히하고 개발과 운영이 따로는 상황을 막아 시스템의 일관성을 부여하기 위한 **문화**이죠.

그러니까 현재 대한민국 소프트웨어 산업에서 일어나고 있는 부서 구분인 백엔드팀, 프론트엔드팀, DevOps팀, 인프라팀 등은

DevOps에 대한 의미 파악의 부재입니다.

DevOps는 기술 스택이나 직군이 아닙니다.

애초에 이건 개발을 해봤다면 나올 수 있는 발상이 아니기도 하죠.

예를 들어 실제 MSA 방식으로 설계를 하고 구현을 한다면, 

코어 서비스 구현 시 설정 파일과 코드에 직접적으로 중간 계층과 인프라와 관련된 내용들이 들어가게 됩니다.

이걸 분리할 수 있을까요? 내부 코드를 모른다면 당연히 배포도 불가능합니다.

애초에 그러니까 One Product = One Team의 관점으로 접근해야지 시스템 별로 팀을 나누는 구조 자체가 잘못된 것이죠.

이는 한국에서만 나타나는 특유의 기형적인 구조이기도 합니다.

그러면 왜 이런 문제가 발생한 것일까요?

사실 한국 소프트웨어 산업은 제조업 중심의 시각에서 벗어나지 못한 경향이 큽니다.

기존의 다른 공학 계열 산업군과 마찬가지로 "제조업"의 시각에서 똑같이 접근하게 된 경우죠.

소프트웨어 산업은 엄연하게 "서비스업"입니다.

제조업의 시각으로 서비스업을 바라보게 된 결과, 소프트웨어 산업이 아닌 IT 건설업의 형태로 발전하게 되었습니다.

그러니까, 애초에 개발 기술자나 개발자가 아니라 영업이나 기획이 주도하면서 발전하게 된 경향이 큽니다.

물론 이는 한국 소프트웨어 산업이 기술 스택만 따라가고 문화와 철학은 따라가지 못하면서 발생한 문제도 있습니다.

그래서 한국의 주력 소프트웨어 수출은 사실상 SI납품형 수출에 가깝습니다.

대표적인 수출 소프트웨어로, 스마트시티, 전자정부 플랫폼, 국가 인프라 관리 시스템, 보안 관제 등입니다.

즉, 국가 간 MOU를 통해 현지 인프라가 깔리면서 부가적으로 따라들어오는 구조인 것이죠.

건설업, 행정 시스템 수출이 소프트웨어 수출을 주도하는 기형적인 산업 구조로 변절된 것입니다.

이는 미국식 SaaS 수출과는 전혀 다른 방식입니다.

한국식 소프트웨어 산업은 2차산업의 부가 가치로 인프라 지원의 형태라면, 미국식 소프트웨어는 아키텍처 중심의 구독 모델로 수익을 벌어들인다는 점에서 완전히 다른 산업의 길을 걷고 있는 셈이죠.

애초에 시작부터 한국 소프트웨어 산업에서는 MSA나 DevOps같은 문화가 제대로 자리잡힐 기회조차 없었던 것이죠.

그저 기술 스택만 수입되었지, 본질적인 철학이나 문화가 들어올 자리는 없었던 것입니다.

그러니까 SaaS라는 개념도 제대로 자리 잡을 기회조차 없었습니다.

그러면 SaaS의 본질은 무엇일까요?

SaaS는 웹으로 제공하는 서비스가 아닙니다.

  1. 하나의 코드베이스가 여러 클라이언트에게 동시 서비스

  2. 고객은 신경쓰지 않는 자동 업데이트와 배포

  3. 월 단위/사용량 기반의 수익 구조

즉, **기술적으로는 누구나 접근 가능하고 구독 모델로 수익을 버는 구조**가 진짜 SaaS인 것입니다.

이러한 SaaS를 비즈니스 모델로 하는 한국 기업들은 극히 드뭅니다.

한국 SaaS의 문제점은

  1. 공공, 인프라, B2B 중심의 프로젝트형 수익

  2. 폐쇄형 플랫폼 구조(API 공개안함)

  3. DevOps 개념 부재(문화가 아니라 기술이나 직군으로 산업계 단위로 착각)

  4. 클라우드 사용 = SaaS로 착각

  5. 단기 수익 중심, 장기 제품화 전략 부재

등이 있습니다.

한국에서 완전한 SaaS를 운영하는 대표 기업은

  라인, 당근, 잔디, 샌드버드(미국 본사), 원티드

정도의 소수 기업들뿐입니다.

근본적으로 이는 한국 개발 문화에도 책임이 있기도 합니다.

아직까지도 00년대에 개발 문화가 묶여있는 곳이 많기도 하고, 사실상 붕괴해버린 멘토링 제도가 이를 가속화한 면도 있습니다.

납품 중심으로 프로젝트 단위로만 개발하면 끝이기에 굳이 기술을 발전시킬 이유도 없고, 멘토링이 붕괴했으니, 신입은 혼자서 공부해야하는 악순환에 갇히게 되었죠.

그러나 코로나 이후로 트랜드는 따라가야하니까 기술 스택을 어거지로 넣고 따라가기 급급한 현상이 발생하였습니다.

당연히 개발자로서의 철학도 전문성도 결여될 수 밖에 없는 구조였습니다.

그리고 가장 큰 문제는 한국 기술자들 특유의 **정치 회피** 습성입니다.

정치적 중립을 빌미로 책임 주체가 사라져서 발전이 멈춘 결과입니다.

이것이 기술적인 판단조차 정치의 문제로 넘겨버리면서 지금까지도 00년대의 기술들이 20년대에 쓰이고,

기술 스택들을 보여주기식으로 제대로 된 이해도 없이 쓰는 문화가 탄생한 것이죠.

이는 REST를 최초로 논문으로 발표한 로이필딩이 제일 피해야 된다고 말한 Design-by-buzzword가 현실화된 것입니다.

사실 이는 기업 입장에서도 좋지 않습니다.

개인이 성장하면 자동으로 조직을 떠나는 구조입니다.

미국의 SaaS기업의 경우에는, 기술로 기업이 성장하면 기업이 기술을 성장시키는 구조를 자주 보이곤 합니다.

대표적으로 Facebook의 react, Google의 kubernetes가 있습니다.

즉, 처음부터 기술을 만드려고 한 게 아니라 서비스를 운영하면서 부딪힌 문제를 해결하기 위해서 기술이 탄생하는 구조인거죠.

운영이 곧 기술의 혁신을 이끄는 구조인겁니다.

그러니까 자연스럽게 안정적인 운영을 추구하게 되고,

수많은 문제들로부터 안정적인 운영을 위해서 수평적인 분위기와 자율적인 분위기가 자연스럽게 기업 문화로 자리잡게 되는 순환입니다.

반면 한국은 기술적인 문제를 기술로 해결하는게 아니라 행정 차원에서 덮어버리는 구조인 것입니다.

운영을 깊게 다루다보면 자연스럽게 기술의 깊이가 발생하는 것인데, 한국은 운영에서 터지는 문제를 덮고 보니 트랜드에 대한 이해가 전무한 상태로 따라가기만 반복되는 것입니다.

운영의 고도화는 자동적으로 기술의 고도화로 이루어집니다. 그 예로,

  자동화 추구 -> Kubernetes, CI/CD, IaC 등장
  확장성 한계 -> Container, MSA, REST
  장애 대응, 복잡도 증가 -> Observability, Distributed Tracing

가 있습니다.

운영을 진지하게, 장기적으로, 큰 그림에서 보게 되면 엔지니어링이 자동으로 이루어집니다.

이렇게 기업이 운영의 안정기에 접어들게 되면, 자동적으로 **자기 반성**을 하게 됩니다.

무슨 말이냐면, 자기 기술들이 정말 이대로 더 성장할 수 있는 지에 대해서 고민을 하게 된다는 것입니다.

Facebook의 경우, 수 천만명이 동시에 페이지를 요청하고, 시스템이 커지면서 UI관리가 힘들어지자 이게 과연 지속가능한지

의심하며 탄생하게 된 것이 React였습니다.

그러나 한국 개발 문화(전 세계에 유래가 없음, 중국도 이러지는 않음)는 문제점을 얘기하면 갈등을 유발한다고 보고, 운영을 발전시키기보다는 유지하고자 하는 문화가 전반에 깔렸기 때문에 애초에 DevOps가 문화로써 받아들여질 수 없었습니다.